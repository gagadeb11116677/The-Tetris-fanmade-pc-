<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>The Tetris (Fanmade)</title>
<style>
    :root {
        --cell: 30px;
        --cols: 10;
        --rows: 20;
    }
    * { box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body {
        margin: 0;
        background: #0a0a0a;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        color: white;
    }
    .wrapper {
        display: flex;
        gap: 40px;
        margin-bottom: 20px;
    }
    canvas {
        background: #111;
        border: 2px solid #0ff;
        box-shadow: 0 0 20px #0ff, inset 0 0 20px #0ff;
        image-rendering: pixelated;
    }
    #scoreBoard {
        min-width: 150px;
    }
    #scoreBoard h2 {
        margin-bottom: 10px;
        text-shadow: 0 0 10px #0ff;
    }
    #scoreBoard p {
        margin: 4px 0;
        font-size: 18px;
    }
    #next {
        width: 120px;
        height: 120px;
        background: #222;
        border: 2px solid #555;
        margin: 10px 0;
    }
    footer {
        font-size: 13px;
        opacity: 0.5;
        color: #aaa;
        margin-top: auto;
        padding: 10px;
        text-align: center;
    }
</style>
</head>
<body>
<h1 style="text-shadow: 0 0 15px #0ff; margin-bottom: 20px;">The Tetris <small style="font-size:14px;">(Fanmade)</small></h1>

<div class="wrapper">
    <canvas id="board"></canvas>
    <div id="scoreBoard">
        <h2>Game Info</h2>
        <p>Skor: <span id="score">0</span></p>
        <p>Level: <span id="level">1</span></p>
        <p>Baris: <span id="lines">0</span></p>
        <p>Selanjutnya:</p>
        <canvas id="next" width="120" height="120"></canvas>
        <p style="font-size:14px;margin-top:20px">
            Kontrol:<br/>
            ← → : Geser<br/>
            ↓ : Drop cepat<br/>
            ↑ : Rotasi<br/>
            Space : Hard drop
        </p>
    </div>
</div>

<footer>
    Dibuat dengan ❤️ oleh <strong>Nama Kamu</strong> | The Tetris (Fanmade) © 2025<br>
    Terinspirasi oleh game Tetris klasik. Semua hak cipta milik pemilik asli.
</footer>

<script>
const COLS = 10, ROWS = 20, SIZE = 30;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = COLS * SIZE;
canvas.height = ROWS * SIZE;

const nextCanvas = document.getElementById('next');
const nextCtx = nextCanvas.getContext('2d');

const SHAPES = [
    [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
    [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]],
    [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
];
const COLORS = ['#0ff','#ff0','#f0f','#0f0','#f00','#00f','#fa0'];

let board = createMatrix(COLS, ROWS);
let current = {}, nextPiece = null;
let score = 0, lines = 0, level = 1, lastTime = 0, particles = [];

function createMatrix(w, h) {
    return Array.from({length: h}, () => Array(w).fill(0));
}
function drawCell(x, y, color, alpha = 1) {
    ctx.globalAlpha = alpha;
    const grad = ctx.createLinearGradient(x * SIZE, y * SIZE, x * SIZE + SIZE, y * SIZE + SIZE);
    grad.addColorStop(0, "#fff");
    grad.addColorStop(1, color);
    ctx.fillStyle = grad;
    ctx.fillRect(x * SIZE, y * SIZE, SIZE, SIZE);
    ctx.strokeStyle = "#222";
    ctx.strokeRect(x * SIZE, y * SIZE, SIZE, SIZE);
    ctx.globalAlpha = 1;
}
function drawMatrix(mat, offsetX, offsetY, color, alpha = 1) {
    mat.forEach((row, y) => {
        row.forEach((val, x) => {
            if(val) drawCell(x + offsetX, y + offsetY, color, alpha);
        });
    });
}
function rotate(matrix) {
    return matrix[0].map((_, i) => matrix.map(row => row[i])).reverse();
}
function collide(piece = current) {
    return piece.shape.some((row, y) => {
        return row.some((val, x) => {
            return val && (board[y + piece.y]?.[x + piece.x] !== 0);
        });
    });
}
function merge() {
    current.shape.forEach((row, y) => {
        row.forEach((val, x) => {
            if(val) board[y + current.y][x + current.x] = current.color;
        });
    });
}
function lineClear() {
    let cleared = 0;
    for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
            y++;
            createParticles(y * SIZE);
        }
    }
    if (cleared) {
        score += (cleared === 4 ? 800 : cleared * 100) * level;
        lines += cleared;
        level = Math.floor(lines / 10) + 1;
        updateStats();
    }
}
function createParticles(y) {
    for (let i = 0; i < 25; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 4,
            life: 40
        });
    }
}
function drawParticles() {
    particles.forEach(p => {
        ctx.beginPath();
        ctx.fillStyle = `rgba(0,255,255,${p.life/40})`;
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
    });
}
function updateParticles() {
    particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
    });
    particles = particles.filter(p => p.life > 0);
}
function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (board[y][x]) {
                drawCell(x, y, board[y][x]);
            }
        }
    }
}
function drawCurrent() {
    let ghost = {...current, y: current.y};
    while (!collide(ghost)) ghost.y++;
    ghost.y--;
    drawMatrix(ghost.shape, ghost.x, ghost.y, current.color, 0.2); // ghost
    drawMatrix(current.shape, current.x, current.y, current.color);
}
function drop() {
    current.y++;
    if (collide()) {
        current.y--;
        merge();
        lineClear();
        spawn();
    }
}
function hardDrop() {
    while (!collide()) current.y++;
    current.y--;
    merge();
    lineClear();
    spawn();
}
function updateStats() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
}
function drawNext() {
    nextCtx.clearRect(0, 0, 120, 120);
    nextCtx.fillStyle = "#000";
    nextCtx.fillRect(0, 0, 120, 120);
    const s = nextPiece.shape;
    const offsetX = (4 - s[0].length) / 2;
    const offsetY = (4 - s.length) / 2;
    nextCtx.fillStyle = nextPiece.color;
    s.forEach((row, y) => {
        row.forEach((val, x) => {
            if (val) {
                nextCtx.fillRect((x + offsetX) * 30, (y + offsetY) * 30, 30, 30);
                nextCtx.strokeStyle = "#fff";
                nextCtx.strokeRect((x + offsetX) * 30, (y + offsetY) * 30, 30, 30);
            }
        });
    });
}
function randomPiece() {
    const i = Math.floor(Math.random() * SHAPES.length);
    return {shape: SHAPES[i], color: COLORS[i]};
}
function spawn() {
    current = {
        shape: nextPiece.shape,
        color: nextPiece.color,
        x: Math.floor((COLS - nextPiece.shape[0].length) / 2),
        y: 0
    };
    nextPiece = randomPiece();
    drawNext();
    if (collide()) {
        board = createMatrix(COLS, ROWS);
        score = lines = 0;
        level = 1;
        nextPiece = randomPiece();
        updateStats();
    }
}
function update(time = 0) {
    const delta = time - lastTime;
    if (delta > 1000 / (level * 0.5 + 1)) {
        drop();
        lastTime = time;
    }
    drawBoard();
    drawCurrent();
    updateParticles();
    drawParticles();
    requestAnimationFrame(update);
}
document.addEventListener("keydown", e => {
    switch (e.code) {
        case "ArrowLeft": current.x--; if (collide()) current.x++; break;
        case "ArrowRight": current.x++; if (collide()) current.x--; break;
        case "ArrowDown": drop(); break;
        case "ArrowUp":
            const r = rotate(current.shape);
            const prev = current.shape;
            current.shape = r;
            if (collide()) current.shape = prev;
            break;
        case "Space": hardDrop(); break;
    }
});
nextPiece = randomPiece();
spawn();
update();
</script>
</body>
</html>
